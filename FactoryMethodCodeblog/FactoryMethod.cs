namespace FactoryMethodCodeblog
{
    /// <summary>
    /// Создатель (Обобщенный Создатель).
    /// Интерфейс или абстрактный класс, 
    /// который определяет сигнатуру фабричного метода для создания продуктов.
    /// Он должен возвращать Обобщенный продукт.
    /// Данный класс один и общий для всех конкретных создателей.
    /// 
    /// В рассмотренном ранее примере, это MessageBase(IMessanger),
    /// Который определял интерфейс создания сообщения, 
    /// но реализацию логики передавал классам наследникам.
    /// </summary>
    public abstract class Creator
    {
        /// <summary>
        /// Фабричный метод определяющий сигнатуру метода создания продукта.
        /// При желании может содержать реализацию по умолчанию (если это класс, а не интерфейс)
        /// </summary>
        /// <returns> Обобщенный продукт. </returns>
        public abstract IProduct FactoryMethod();

        // Данный класс дополнительно может содержать общую логику для всех конкретных создателей при необходимости.
    }


    /// <summary>
    /// Создатель (Конкретный Создатель).
    /// Класс конкретного создателя конкретного продукта, который реализует фабричный метод.
    /// Для каждого продукта необходим свой создатель. Конкретных создателей может быть много.
    /// 
    /// В рассмотренном нами примере, это были реализации
    /// для работы с конкретными мессенджерами: TwitterMessanger, InstagramMessanger, TelegramMessanger.
    /// </summary>
    public class ConcreteCreator : Creator
    {
        /// <summary>
        /// Конкретная реализация фабричного метод.
        /// Определяет процесс создания конкретного продукта,
        /// при этом возвращая обобщенный продукт (интерфейс или абстрактный класс продукта).
        /// Благодаря этому появляется возможность обобщенному создателю
        /// не зависеть от конкретных реализаций продукта и создателя этого продукта.
        /// </summary>
        /// <returns> Конкретный продукт, упакованный в виде обобщенного продукта. </returns>
        public override IProduct FactoryMethod()
        {
            // При необходимости здесь могут быть дополнительные действия,
            // кроме непосредственного создания конкретного продукта.
            return new ConcreteProduct();
        }
    }

    /// <summary>
    /// Продукт (Обобщенный Продукт).
    /// Интерфейс или абстрактный класс, 
    /// который определяет общие для всех продуктов свойства и методы
    /// (то есть характеристики и действия, которые будут на 100% у всех конкретных продуктов)
    /// При этом при необходимости может содержать базовую реализацию (если это класс).
    /// Данный класс (интерфейс) один и является общим для всех конкретных продуктов.
    /// 
    /// В нашем примере это был MessageBase (IMessage), который определял
    /// поля и методы для отправки сообщения.
    /// </summary>
    public interface IProduct
    {
        string Name { get; set; }
        void DoWork();
    }

    /// <summary>
    /// Продукт (Конкретный продукт).
    /// Класс определяющий поведение конкретного продукта. 
    /// Для каждого конкретного продукта необходим свой собственный конкретный создатель.
    /// Конкретных продуктов может быть много.
    /// 
    /// В рассмотренном нами примере это были конкретные реализации
    /// типов сообщений TwitterMessage, InstagramMessage, TelegramMessage.
    /// </summary>
    public class ConcreteProduct : IProduct
    {
        public string Name { get; set; }

        public void DoWork()
        {
            // Magic!
        }
    }
}
